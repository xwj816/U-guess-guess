<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gartic È¢®Ê†ºÁï´Â∏É</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="canvas-wrapper">
        <canvas id="myCanvas" width="800" height="500"></canvas>
        
        <div class="toolbar">
            <div class="tools-left">
                <button class="tool-btn active" onclick="setTool('pen')" title="Á≠ÜÂà∑">‚úèÔ∏è</button>
                <button class="tool-btn" onclick="setTool('fill')" title="Ê≤πÊºÜÊ°∂">ü™£</button>
                <button class="tool-btn" onclick="setTool('eraser')" title="Ê©°ÁöÆÊì¶">üßº</button>
                <button class="tool-btn btn-clear" onclick="clearServerCanvas()" title="Ê∏ÖÁ©∫">üóëÔ∏è</button>
            </div>

            <input type="range" class="size-slider" id="sizePicker" min="2" max="40" value="5" title="Á≠ÜÂà∑Á≤óÁ¥∞">

            <div class="colors" id="colorPalette">
                </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const userId = 'user_' + Math.random().toString(36).substr(2, 9); 

        let currentTool = 'pen';
        let currentColor = '#000000';
        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let lastSyncedId = 0; 

        // ÂàùÂßãÂåñËâ≤Á•®
        const colors = [
            '#000000', '#555555', '#aaaaaa', '#ffffff', 
            '#ff0000', '#ff8800', '#ffff00', '#aaff00', 
            '#00ff00', '#00ffaa', '#00ffff', '#0088ff', 
            '#0000ff', '#8800ff', '#ff00ff', '#ff0088',
            '#660000', '#663300', '#666600', '#336600',
            '#006666'
        ];
        
        const paletteContainer = document.getElementById('colorPalette');
        colors.forEach((c, index) => {
            const div = document.createElement('div');
            div.className = `color-swatch ${index === 0 ? 'active' : ''}`;
            div.style.backgroundColor = c;
            div.onclick = () => selectColor(c, div);
            paletteContainer.appendChild(div);
        });

        function selectColor(color, element) {
            currentColor = color;
            document.querySelectorAll('.color-swatch').forEach(el => el.classList.remove('active'));
            element.classList.add('active');
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(el => el.classList.remove('active'));
            const btnIndex = tool === 'pen' ? 0 : tool === 'fill' ? 1 : tool === 'eraser' ? 2 : -1;
            if(btnIndex >= 0) document.querySelectorAll('.tool-btn')[btnIndex].classList.add('active');
        }

        // Áõ£ËÅΩ
        canvas.addEventListener('mousedown', (e) => {
            const x = e.offsetX;
            const y = e.offsetY;
            if (currentTool === 'fill') {
                drawAndSend(x, y, x, y, 'fill');
            } else {
                isDrawing = true;
                [lastX, lastY] = [x, y];
                drawAndSend(x, y, x, y, currentTool);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            drawAndSend(lastX, lastY, e.offsetX, e.offsetY, currentTool);
            [lastX, lastY] = [e.offsetX, e.offsetY];
        });

        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseout', () => isDrawing = false);

        // ÂÇ≥ÈÄÅ
        function drawAndSend(x0, y0, x1, y1, type) {
            const size = document.getElementById('sizePicker').value;
            renderStroke(x0, y0, x1, y1, currentColor, size, type);
            fetch('/api/draw', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    user_id: userId,
                    x0, y0, x1, y1, 
                    color: currentColor, size, type
                })
            });
        }

        // Áπ™ÂúñÈÇèËºØ
        function renderStroke(x0, y0, x1, y1, color, size, type) {
            if (type === 'fill') {
                floodFill(Math.floor(x0), Math.floor(y0), color);
                return;
            }
            ctx.beginPath();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = size;
            ctx.strokeStyle = (type === 'eraser') ? '#ffffff' : color;
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
            ctx.closePath();
        }

        // Ê≤πÊºÜÊ°∂ÊºîÁÆóÊ≥ï
        function floodFill(startX, startY, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const r = parseInt(fillColor.slice(1, 3), 16);
            const g = parseInt(fillColor.slice(3, 5), 16);
            const b = parseInt(fillColor.slice(5, 7), 16);
            const a = 255;

            const startPos = (startY * canvas.width + startX) * 4;
            const startR = data[startPos];
            const startG = data[startPos + 1];
            const startB = data[startPos + 2];
            const startA = data[startPos + 3];

            if (startR === r && startG === g && startB === b && startA === a) return;

            const stack = [[startX, startY]];
            while (stack.length) {
                const [x, y] = stack.pop();
                const pos = (y * canvas.width + x) * 4;
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;
                if (data[pos] !== startR || data[pos + 1] !== startG || data[pos + 2] !== startB || data[pos + 3] !== startA) continue;

                data[pos] = r; data[pos + 1] = g; data[pos + 2] = b; data[pos + 3] = a;
                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // ÂêåÊ≠•
        setInterval(() => {
            fetch(`/api/fetch_strokes?last_id=${lastSyncedId}`)
                .then(res => res.json())
                .then(data => {
                    if (data.strokes && data.strokes.length > 0) {
                        data.strokes.forEach(stroke => {
                            if (stroke.user_id !== userId) {
                                renderStroke(stroke.x0, stroke.y0, stroke.x1, stroke.y1, stroke.color, stroke.size, stroke.type);
                            }
                            lastSyncedId = stroke.id;
                        });
                    }
                })
                .catch(err => console.error(err));
        }, 500);

        function clearServerCanvas() {
            if(confirm('Á¢∫ÂÆöË¶ÅÊ∏ÖÁ©∫ÂóéÔºü')) {
                fetch('/api/clear', { method: 'POST' }).then(() => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    lastSyncedId = 0;
                    location.reload();
                });
            }
        }
    </script>
</body>
</html>