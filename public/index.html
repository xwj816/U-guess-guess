<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>å…¨è£ç½®åŒæ­¥ç•«å¸ƒ</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="canvas-wrapper">
        <canvas id="myCanvas" width="800" height="500"></canvas>
        
        <div class="toolbar">
            <div class="tools-left">
                <button class="tool-btn active" onclick="setTool('pen')">âœï¸</button>
                <button class="tool-btn" onclick="setTool('fill')">ğŸª£</button>
                <button class="tool-btn" onclick="setTool('eraser')">ğŸ§¼</button>
                <button class="tool-btn btn-clear" onclick="clearServerCanvas()">ğŸ—‘ï¸</button>
            </div>

            <input type="range" class="size-slider" id="sizePicker" min="2" max="40" value="5">

            <div class="colors" id="colorPalette"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const userId = 'user_' + Math.random().toString(36).substr(2, 9); 

        let currentTool = 'pen';
        let currentColor = '#000000';
        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let lastSyncedId = 0; 
        let localVersion = -1; // æ–°å¢ï¼šç´€éŒ„æœ¬åœ°ç›®å‰çš„ç‰ˆæœ¬è™Ÿ (-1 ä»£è¡¨å‰›é€²ä¾†)

        // ç”¢ç”Ÿè‰²ç¥¨
        const colors = [
            '#000000', '#555555', '#ffffff', '#ff0000', '#ff8800', 
            '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#800080'
        ];
        const paletteContainer = document.getElementById('colorPalette');
        colors.forEach((c, index) => {
            const div = document.createElement('div');
            div.className = `color-swatch ${index === 0 ? 'active' : ''}`;
            div.style.backgroundColor = c;
            div.onclick = () => selectColor(c, div);
            paletteContainer.appendChild(div);
        });

        function selectColor(color, element) {
            currentColor = color;
            document.querySelectorAll('.color-swatch').forEach(el => el.classList.remove('active'));
            element.classList.add('active');
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(el => el.classList.remove('active'));
            const index = tool === 'pen' ? 0 : tool === 'fill' ? 1 : 2;
            if(index >= 0) document.querySelectorAll('.tool-btn')[index].classList.add('active');
        }

        // --- æ ¸å¿ƒï¼šå–å¾—æ­£ç¢ºåº§æ¨™ (æ”¯æ´æ»‘é¼ èˆ‡è§¸æ§) ---
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            // è¨ˆç®— CSS ç¸®æ”¾å¾Œçš„æ¯”ä¾‹
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            let clientX, clientY;

            // åˆ¤æ–·æ˜¯è§¸æ§é‚„æ˜¯æ»‘é¼ 
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        // --- äº‹ä»¶ç›£è½ (æ•´åˆ Mouse & Touch) ---
        
        // é–‹å§‹ç•«
        function startDraw(e) {
            e.preventDefault(); // é˜²æ­¢æ‰‹æ©Ÿç•«é¢æ²å‹•
            const pos = getPos(e);
            
            if (currentTool === 'fill') {
                drawAndSend(pos.x, pos.y, pos.x, pos.y, 'fill');
            } else {
                isDrawing = true;
                [lastX, lastY] = [pos.x, pos.y];
                // é»ä¸€ä¸‹ä¹Ÿç•«å€‹é»
                drawAndSend(pos.x, pos.y, pos.x, pos.y, currentTool);
            }
        }

        // ç§»å‹•ä¸­
        function moveDraw(e) {
            e.preventDefault();
            if (!isDrawing) return;
            const pos = getPos(e);
            drawAndSend(lastX, lastY, pos.x, pos.y, currentTool);
            [lastX, lastY] = [pos.x, pos.y];
        }

        // çµæŸç•«
        function endDraw(e) {
            e.preventDefault();
            isDrawing = false;
        }

        // ç¶å®šé›»è…¦æ»‘é¼ äº‹ä»¶
        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', moveDraw);
        canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('mouseout', endDraw);

        // ç¶å®šæ‰‹æ©Ÿè§¸æ§äº‹ä»¶
        canvas.addEventListener('touchstart', startDraw, { passive: false });
        canvas.addEventListener('touchmove', moveDraw, { passive: false });
        canvas.addEventListener('touchend', endDraw);

        // --- ç¹ªåœ–é‚è¼¯ (åŒå‰) ---
        function drawAndSend(x0, y0, x1, y1, type) {
            const size = document.getElementById('sizePicker').value;
            renderStroke(x0, y0, x1, y1, currentColor, size, type);
            
            fetch('/api/draw', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    user_id: userId,
                    x0, y0, x1, y1, color: currentColor, size, type
                })
            });
        }

        function renderStroke(x0, y0, x1, y1, color, size, type) {
            if (type === 'fill') {
                floodFill(Math.floor(x0), Math.floor(y0), color);
                return;
            }
            ctx.beginPath();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = size;
            ctx.strokeStyle = (type === 'eraser') ? '#ffffff' : color;
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
            ctx.closePath();
        }

        function floodFill(startX, startY, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const r = parseInt(fillColor.slice(1, 3), 16);
            const g = parseInt(fillColor.slice(3, 5), 16);
            const b = parseInt(fillColor.slice(5, 7), 16);
            
            const startPos = (startY * canvas.width + startX) * 4;
            const startR = data[startPos], startG = data[startPos+1], startB = data[startPos+2], startA = data[startPos+3];

            if (startR === r && startG === g && startB === b && startA === 255) return;

            const stack = [[startX, startY]];
            while (stack.length) {
                const [x, y] = stack.pop();
                const pos = (y * canvas.width + x) * 4;
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;
                if (data[pos] !== startR || data[pos+1] !== startG || data[pos+2] !== startB || data[pos+3] !== startA) continue;

                data[pos] = r; data[pos+1] = g; data[pos+2] = b; data[pos+3] = 255;
                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // åŒæ­¥
        setInterval(() => {
            // è«‹æ±‚æ™‚ä¸ç”¨ç‰¹åˆ¥å¸¶ versionï¼ŒServer æœƒä¸»å‹•çµ¦
            fetch(`/api/fetch_strokes?last_id=${lastSyncedId}`)
                .then(res => res.json())
                .then(data => {
                    // A. æª¢æŸ¥ç‰ˆæœ¬è™Ÿï¼šå¦‚æœæ˜¯ç¬¬ä¸€æ¬¡è¼‰å…¥ (-1)ï¼Œç›´æ¥åŒæ­¥ç‰ˆæœ¬
                    if (localVersion === -1) {
                        localVersion = data.version;
                    }
                    // B. é—œéµï¼šå¦‚æœ Server ç‰ˆæœ¬æ¯”æˆ‘å¤§ï¼Œä»£è¡¨æœ‰äººæ¸…ç©ºäº†ï¼
                    else if (data.version > localVersion) {
                        console.log("åµæ¸¬åˆ°ç•«å¸ƒæ¸…ç©ºï¼");
                        ctx.clearRect(0, 0, canvas.width, canvas.height); // æ¸…ç•«é¢
                        lastSyncedId = 0;             // ID æ­¸é›¶
                        localVersion = data.version;  // æ›´æ–°ç‰ˆæœ¬è™Ÿ
                        // æ³¨æ„ï¼šé€™æ¬¡å°±ä¸ç”¨ç•«ç·šäº†ï¼Œå› ç‚ºå·²ç¶“æ¸…ç©º
                        return; 
                    }

                    // C. æ­£å¸¸çš„ç•«ç·šé‚è¼¯
                    if (data.strokes && data.strokes.length > 0) {
                        data.strokes.forEach(s => {
                            if (s.user_id !== userId) {
                                renderStroke(s.x0, s.y0, s.x1, s.y1, s.color, s.size, s.type);
                            }
                            lastSyncedId = s.id;
                        });
                    }
                })
                .catch(e => console.error(e));
        }, 500);

        function clearServerCanvas() {
            fetch('/api/clear', { method: 'POST' })
                .then(res => res.json())
                .then(data => {
                    // è‡ªå·±æŒ‰æ¸…ç©ºçš„äººï¼Œç›´æ¥é‡æ•´æˆ–æ¸…ç©ºå°±å¥½
                    // é€™è£¡æˆ‘å€‘ç°¡å–®é»ï¼Œç›´æ¥æ¸…ç©ºæœ¬åœ°ä¸¦æ›´æ–°ç‰ˆæœ¬
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    lastSyncedId = 0;
                    localVersion = data.version;
                });
        }
    </script>
</body>

</html>
